package com.hashedin.huspark;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class LibraryApplication {
    public static void main(String[] args) {
        SpringApplication.run(LibraryApplication.class, args);
    }
}







package com.hashedin.huspark.model.audit;

import jakarta.persistence.*;
import java.time.Instant;

@Entity
@Table(name = "audit_logs")
public class AuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String actor;
    private String action;
    private Instant at;

    @Lob
    @Column(name = "details_encrypted")
    private String detailsEncrypted;

    private String path;
    private String method;

    public AuditLog() {}

    public AuditLog(String actor, String action, Instant at, String detailsEncrypted, String path, String method) {
        this.actor = actor;
        this.action = action;
        this.at = at;
        this.detailsEncrypted = detailsEncrypted;
        this.path = path;
        this.method = method;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getActor() { return actor; }
    public void setActor(String actor) { this.actor = actor; }

    public String getAction() { return action; }
    public void setAction(String action) { this.action = action; }

    public Instant getAt() { return at; }
    public void setAt(Instant at) { this.at = at; }

    public String getDetailsEncrypted() { return detailsEncrypted; }
    public void setDetailsEncrypted(String detailsEncrypted) { this.detailsEncrypted = detailsEncrypted; }

    public String getPath() { return path; }
    public void setPath(String path) { this.path = path; }

    public String getMethod() { return method; }
    public void setMethod(String method) { this.method = method; }
}







package com.hashedin.huspark.model.transaction;

import com.hashedin.huspark.model.book.Book;
import com.hashedin.huspark.model.User;
import jakarta.persistence.*;
import java.time.LocalDate;

@Entity
@Table(name = "borrowing_transactions")
public class BorrowingTransaction {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY) private Book book;
    @ManyToOne(fetch = FetchType.LAZY) private User user;

    private LocalDate borrowDate;
    private LocalDate dueDate;
    private LocalDate returnDate;
    private boolean overdueNotified = false;

    public BorrowingTransaction() {}

    @Transient
    public boolean isOverdue() {
        return returnDate == null && dueDate != null && LocalDate.now().isAfter(dueDate);
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Book getBook() { return book; }
    public void setBook(Book book) { this.book = book; }

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    public LocalDate getBorrowDate() { return borrowDate; }
    public void setBorrowDate(LocalDate borrowDate) { this.borrowDate = borrowDate; }

    public LocalDate getDueDate() { return dueDate; }
    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }

    public LocalDate getReturnDate() { return returnDate; }
    public void setReturnDate(LocalDate returnDate) { this.returnDate = returnDate; }

    public boolean isOverdueNotified() { return overdueNotified; }
    public void setOverdueNotified(boolean overdueNotified) { this.overdueNotified = overdueNotified; }
}







package com.hashedin.huspark.model;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Column(unique = true)
    private String email;

    private String passwordHash;

    public User() {}

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }
}







package com.hashedin.huspark.payload.response;

public class MaskedUserResponse {
    private Long id;
    private String name;
    private String maskedEmail;

    public MaskedUserResponse(Long id, String name, String maskedEmail) {
        this.id = id;
        this.name = name;
        this.maskedEmail = maskedEmail;
    }

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getMaskedEmail() { return maskedEmail; }
    public void setMaskedEmail(String maskedEmail) { this.maskedEmail = maskedEmail; }
}







package com.hashedin.huspark.repository;

import com.hashedin.huspark.model.audit.AuditLog;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {}
}







package com.hashedin.huspark.repository;

import com.hashedin.huspark.model.transaction.BorrowingTransaction;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import java.time.LocalDate;
import java.util.List;

public interface TransactionRepository extends JpaRepository<BorrowingTransaction, Long> {
    List<BorrowingTransaction> findByReturnDateIsNullAndDueDateBefore(LocalDate date);
    List<BorrowingTransaction> findByReturnDateIsNullAndDueDateBeforeAndOverdueNotifiedFalse(LocalDate date);

    @Query("SELECT bt.book.title, COUNT(bt.id) FROM BorrowingTransaction bt GROUP BY bt.book.title ORDER BY COUNT(bt.id) DESC")
    List<Object[]> findMostBorrowedBooks(Pageable pageable);
}







package com.hashedin.huspark.repository;

import com.hashedin.huspark.model.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findByNameContainingIgnoreCaseOrEmailContainingIgnoreCase(String name, String email, Pageable pageable);
}







package com.hashedin.huspark.repository;

import com.hashedin.huspark.model.book.Book;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;

public interface BookRepository extends JpaRepository<Book, Long> {
    Page<Book> findByTitleContainingIgnoreCase(String q, Pageable pageable);
}







package com.hashedin.huspark.util;

public final class MaskingUtil {
    public static String maskEmail(String email) {
        if (email == null || !email.contains("@")) return "****";
        String[] parts = email.split("@", 2);
        String local = parts[0];
        if (local.length() <= 2) return "*" + "@" + parts[1];
        return local.charAt(0) + "***@" + parts[1];
    }
}







package com.hashedin.huspark.util;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

public class CryptoUtil {
    public static String encrypt(String plain, String secret) {
        try {
            byte[] iv = new byte[12];
            new SecureRandom().nextBytes(iv);
            SecretKeySpec key = new SecretKeySpec(secret.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, key, new GCMParameterSpec(128, iv));
            byte[] encrypted = cipher.doFinal(plain.getBytes(StandardCharsets.UTF_8));
            byte[] combined = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, combined, 0, iv.length);
            System.arraycopy(encrypted, 0, combined, iv.length, encrypted.length);
            return Base64.getEncoder().encodeToString(combined);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}







package com.hashedin.huspark.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hashedin.huspark.model.audit.AuditLog;
import com.hashedin.huspark.repository.AuditLogRepository;
import com.hashedin.huspark.util.CryptoUtil;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.security.Principal;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Component
public class AuditInterceptor implements HandlerInterceptor {
    private final AuditLogRepository repo;
    private final ObjectMapper mapper;

    @Value("${audit.secret:demo-secret}")
    private String secret;

    public AuditInterceptor(AuditLogRepository repo, ObjectMapper mapper) {
        this.repo = repo;
        this.mapper = mapper;
    }

    @Override
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) throws Exception {
        String method = req.getMethod();
        if (!("POST".equals(method) || "PUT".equals(method) || "DELETE".equals(method))) return true;

        Principal principal = req.getUserPrincipal();
        String actor = principal != null ? principal.getName() : "anonymous";

        Map<String, Object> details = new HashMap<>();
        details.put("query", req.getQueryString());
        details.put("ip", req.getRemoteAddr());

        String json = mapper.writeValueAsString(details);
        String encrypted = CryptoUtil.encrypt(json, secret);

        AuditLog log = new AuditLog(actor, "HTTP_" + method, Instant.now(), encrypted, req.getRequestURI(), method);
        repo.save(log);
        return true;
    }
}







package com.hashedin.huspark.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class AuditConfig implements WebMvcConfigurer {
    private final AuditInterceptor interceptor;

    public AuditConfig(AuditInterceptor interceptor) {
        this.interceptor = interceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(interceptor);
    }
}







package com.hashedin.huspark.logging;

import jakarta.servlet.FilterChain;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class StructuredLoggingFilter extends OncePerRequestFilter {
    private static final Logger log = LoggerFactory.getLogger(StructuredLoggingFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)
            throws IOException, jakarta.servlet.ServletException {
        long start = System.currentTimeMillis();
        chain.doFilter(req, res);
        long duration = System.currentTimeMillis() - start;
        log.info("{{\"event\":\"HTTP\",\"method\":\"{}\",\"path\":\"{}\",\"status\":{},\"duration_ms\":{}}}",
                req.getMethod(), req.getRequestURI(), res.getStatus(), duration);
    }
}







package com.hashedin.huspark.service;

import com.hashedin.huspark.model.transaction.BorrowingTransaction;
import com.hashedin.huspark.repository.TransactionRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
public class NotificationService {
    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);
    private final TransactionRepository repo;

    public NotificationService(TransactionRepository repo) { this.repo = repo; }

    @Scheduled(cron = "0 0 9 * * *") // daily 9 AM
    public void sendOverdueNotices() {
        List<BorrowingTransaction> overdues = repo.findByReturnDateIsNullAndDueDateBeforeAndOverdueNotifiedFalse(LocalDate.now());
        for (BorrowingTransaction tx : overdues) {
            log.info("OVERDUE: user={} book={} due={}", tx.getUser().getEmail(), tx.getBook().getTitle(), tx.getDueDate());
            tx.setOverdueNotified(true);
        }
    }
}







package com.hashedin.huspark.service;

import com.hashedin.huspark.model.User;
import com.hashedin.huspark.payload.response.MaskedUserResponse;
import com.hashedin.huspark.util.MaskingUtil;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    public MaskedUserResponse toMasked(User user) {
        return new MaskedUserResponse(user.getId(), user.getName(), MaskingUtil.maskEmail(user.getEmail()));
    }
}







package com.hashedin.huspark.controller;

import com.hashedin.huspark.model.transaction.BorrowingTransaction;
import com.hashedin.huspark.repository.TransactionRepository;
import com.hashedin.huspark.service.UserService;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.*;

@RestController
@RequestMapping("/api/reports")
public class ReportController {
    private final TransactionRepository txRepo;
    private final UserService userService;

    public ReportController(TransactionRepository txRepo, UserService userService) {
        this.txRepo = txRepo; this.userService = userService;
    }

    @GetMapping("/most-borrowed")
    public ResponseEntity<?> mostBorrowed(@RequestParam(defaultValue = "5") int top) {
        List<Object[]> rows = txRepo.findMostBorrowedBooks(PageRequest.of(0, top));
        List<Map<String, Object>> result = new ArrayList<>();
        for (Object[] r : rows) {
            Map<String, Object> item = new HashMap<>();
            item.put("title", r[0]);
            item.put("count", r[1]);
            result.add(item);
        }
        return ResponseEntity.ok(result);
    }

    @GetMapping("/overdue")
    public ResponseEntity<?> overdue() {
        List<BorrowingTransaction> list = txRepo.findByReturnDateIsNullAndDueDateBefore(LocalDate.now());
        List<Map<String, Object>> result = new ArrayList<>();
        for (BorrowingTransaction bt : list) {
            Map<String, Object> m = new LinkedHashMap<>();
            m.put("book", bt.getBook().getTitle());
            m.put("dueDate", bt.getDueDate());
            m.put("user", userService.toMasked(bt.getUser()));
            result.add(m);
        }
        return ResponseEntity.ok(result);
    }
}







package com.hashedin.huspark.controller;

import com.hashedin.huspark.model.User;
import com.hashedin.huspark.payload.response.MaskedUserResponse;
import com.hashedin.huspark.repository.UserRepository;
import com.hashedin.huspark.service.UserService;
import org.springframework.data.domain.*;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserRepository repo;
    private final UserService service;

    public UserController(UserRepository repo, UserService service) {
        this.repo = repo; this.service = service;
    }

    @GetMapping
    public ResponseEntity<Page<MaskedUserResponse>> list(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "name") String sort,
            @RequestParam(defaultValue = "asc") String dir,
            @RequestParam(required = false) String q) {

        Pageable pageable = PageRequest.of(page, size, Sort.by("desc".equalsIgnoreCase(dir) ? Sort.Direction.DESC : Sort.Direction.ASC, sort));
        Page<User> users = (q == null) ? repo.findAll(pageable) : repo.findByNameContainingIgnoreCaseOrEmailContainingIgnoreCase(q, q, pageable);

        return ResponseEntity.ok(new PageImpl<>(
                users.getContent().stream().map(service::toMasked).collect(Collectors.toList()),
                pageable,
                users.getTotalElements()
        ));
    }
}
